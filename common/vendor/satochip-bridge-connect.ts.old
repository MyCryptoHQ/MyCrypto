const WebSocket = require('isomorphic-ws') 


export class Device extends EventEmitter {



}

export class DeviceList extends EventEmitter {

	constructor(options: ?DeviceListOptions) {
        super();
    }

	// If there is at least one physical device connected, returns it, steals it if necessary
    stealFirstDevice(rejectOnEmpty?: ?boolean): Promise<Device> {
        const devices = this.asArray();
        if (devices.length > 0) {
            return Promise.resolve(devices[0]);
        }
        const unacquiredDevices = this.unacquiredAsArray();
        if (unacquiredDevices.length > 0) {
            return unacquiredDevices[0].steal();
        }
        if (rejectOnEmpty) {
            return Promise.reject(new Error('No device connected'));
        } else {
            return new Promise((resolve, reject) => {
                this.connectEvent.once(() => {
                    this.stealFirstDevice().then(d => resolve(d), e => reject(e));
                });
            });
        }
    }


}


export class Session extends EventEmitter {


const ws = new WebSocket('ws://localhost:8000/', 
         {origin: 'https://mycrypto.local'});

ws.onopen = function open() {
  console.log('connected');

  //const msg: any= {action:"get_status"}
  const msg: any= {action:"get_chaincode", path:dpath}
  const data: string= JSON.stringify(msg);

  ws.send(data);
  console.log('Request:'+data);
};

ws.onclose = function close() {
  console.log('disconnected');
};

ws.onmessage = function incoming(data: any) {
  console.log('TYPEOF DATA:'+typeof(data));
  console.log('TYPEOF DATA.DATA:'+typeof(data.data));
  console.log('Reply:'+data.data);

  reply= JSON.parse(data.data);
  console.log('Reply JSON:'+reply);

  console.log('Return chaincode:'+reply.chaincode);
  return {
      chainCode: reply.chaincode,
      publicKey: reply.pubkey
  };
  //setTimeout(function timeout() {
  //  ws.send(Date.now());
  //}, 500);
};

}