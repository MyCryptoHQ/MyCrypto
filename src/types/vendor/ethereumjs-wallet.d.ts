declare module 'ethereumjs-wallet/thirdparty' {
  import { IEtherWalletLocked, IEtherWalletUnlocked, Wallet } from 'ethereumjs-wallet';

  /**
   * @description import a brain wallet used by Ether.Camp
   * @param input
   * @param password
   */
  function fromEtherCamp(passphrase: string): Wallet;

  /**
   * @description import a wallet generated by EtherWallet
   * @param input
   * @param password
   */
  function fromEtherWallet(
    input: IEtherWalletLocked | IEtherWalletUnlocked | string,
    password: string
  ): Wallet;

  /**
   * @description  import a wallet from a KryptoKit seed
   * @param entropy
   * @param seed
   */
  function fromKryptoKit(entropy: string, seed: string): Wallet;

  /**
   * @description import a brain wallet used by Quorum Wallet
   * @param passphrase
   * @param userid
   */
  function fromQuorumWallet(passphrase: string, userid: string): Wallet;
}

declare module 'ethereumjs-wallet/hdkey' {
  interface IHDNodePublic {
    /**
     * @description return a BIP32 extended public key (xpub)
     */
    publicExtendedKey(): string;

    /**
     * @description derive a node based on a path (e.g. m/44'/0'/0/1)
     */
    derivePath(path: string): IHDNodePublic;

    /**
     * @description derive a node based on a child index
     */
    deriveChild(index: any): IHDNodePublic;

    /**
     * @description return a Wallet instance
     */
    getWallet(): Wallet;
  }

  /**
   *
   *
   * @interface IHDNodePrivate
   */
  interface IHDNodePrivate {
    /**
     * @description return a BIP32 extended private key (xprv)
     */
    privateExtendedKey(): string;

    /**
     * @description return a BIP32 extended public key (xpub)
     */
    publicExtendedKey(): string;

    /**
     * @description derive a node based on a path (e.g. m/44'/0'/0/1)
     */
    derivePath(path: string): IHDNodePrivate | IHDNodePublic;

    /**
     * @description derive a node based on a child index
     */
    deriveChild(index: any): IHDNodePrivate | IHDNodePublic;

    /**
     * @description return a Wallet instance
     */
    getWallet(): Wallet;
  }

  /**
   * @description create an instance based on a seed
   */
  function fromMasterSeed(seed: Buffer): IHDNodePrivate;

  /**
   * @description create an instance based on a BIP32 extended private or public key
   */
  function fromExtendedKey(key: string): IHDNodePrivate | IHDNodePublic;
}

declare module 'ethereumjs-wallet' {
  interface IPresaleWallet {
    encseed: string;
    ethaddr: string;
    btcaddr: string;
    email: string;
  }

  interface IKdfParams {
    dklen: number;
    salt: string; // Random salt for the kdf. Size must match the requirements of the KDF (key derivation function). Random number generated via crypto.getRandomBytes if nothing is supplied.
  }

  interface IScryptKdfParams extends IKdfParams {
    n: number; // Iteration count. Defaults to 262144.
    r: number; // Block size for the underlying hash. Defaults to 8.
    p: number; // Parallelization factor. Defaults to 1.
  }

  interface IPbkdf2KdfParams extends IKdfParams {
    prf: 'hmac-sha256';
    c: number;
  }

  interface IV1Wallet {
    Version: 1;
    Crypto: {
      KeyHeader: {
        Kdf: 'scrypt';
        KdfParams: {
          N: number;
          R: number;
          P: number;
          DkLen: number;
        };
      };
      MAC: string;
      CipherText: string;
      Salt: string;
      IV: string;
    };
  }

  interface IV3Wallet {
    version: 3;
    id: string;
    address: string;
    crypto: {
      ciphertext: string;
      cipherparams: {
        iv: string;
      };
      cipher: string | 'aes-128-ctr';
      kdf: 'scrypt' | 'pbkdf2';
      kdfparams: IScryptKdfParams | IPbkdf2KdfParams;
      mac: string;
    };
  }

  interface IEtherWalletLocked {
    private: string;
    encrypted: true;
    address: string;
    locked: true;
  }

  interface IEtherWalletUnlocked {
    private: string;
    locked: false;
    encrypted: false;
    address: string;
  }

  interface IV3Options {
    salt?: Buffer; // Random salt for the kdf. Size must match the requirements of the KDF (key derivation function). Random number generated via crypto.getRandomBytes if nothing is supplied.
    iv?: Buffer; // Initialization vector for the cipher. Size must match the requirements of the cipher. Random number generated via crypto.getRandomBytes if nothing is supplied.
    kdf?: string; // The key derivation function, see below.
    dklen?: number; // Derived key length. For certain cipher settings, this must match the block sizes of those.
    uuid?: Buffer; // UUID. One is randomly generated.
    cipher?: string | 'aes-128-ctr' | 'aes-128-cbc'; // The cipher to use. Names must match those of supported by OpenSSL, e.g. aes-128-ctr or aes-128-cbc.

    /* pbkdf2 */
    c?: number; //  Number of iterations. Defaults to 262144.

    /* scrypt */
    n?: number; // Iteration count. Defaults to 262144.
    r?: number; // Block size for the underlying hash. Defaults to 8.
    p?: number; // Parallelization factor. Defaults to 1.
  }

  export default class Wallet {
    _pubKey: string;
    _privKey: string;

    /**
     * @description return the public key
     */
    getPublicKey(): Buffer; //only returns uncompressed Ethereum-style public keys.

    /**
     * @description return the public key
     */
    getPublicKeyString(): string;

    /**
     * @description  return the address
     */
    getAddress(): Buffer;

    /**
     *
     * @description return the address
     */
    getAddressString(): string;

    /**
     * @description  return the address with checksum
     */
    getChecksumAddressString(): string;

    /**
     * @description return the suggested filename for V3 keystores
     */
    getV3Filename(timestamp?: number): string;

    /**
     * @description return the private key
     */
    getPrivateKey(): Buffer;

    /**
     * @description return the private key
     */
    getPrivateKeyString(): string;

    /**
     * @description return the wallet as a JSON string (Version 3 of the Ethereum wallet format)
     */
    toV3(password: string, options?: IV3Options): IV3Wallet;

    /* STATIC METHODS */

    /**
     *
     * @param icap
     * @description create an instance based on a new random key (setting icap to true will generate an address suitable for the ICAP Direct mode
     */
    static generate(icap?: boolean): Wallet;

    /**
     *
     * @param pattern
     * @description create an instance where the address is valid against the supplied pattern (this will be very slow)
     */
    static generateVanityAddress(pattern: string | RegExp): Wallet;

    /**
     * @description create an instance based on a raw private key
     * @param input
     *
     */
    static fromPrivateKey(input: Buffer): Wallet;

    /**
     * @description create an instance based on a BIP32 extended private key (xprv)
     * @param input
     */
    static fromExtendedPrivateKey(input: Buffer): Wallet;

    /**
     * @description create an instance based on a public key (certain methods will not be available)
     * @param input
     * @param nonStrict
     */
    static fromPublicKey(input: Buffer, nonStrict?: boolean): Wallet;

    /**
     * @description  create an instance based on a BIP32 extended public key (xpub)
     * @param input
     */
    static fromExtendedPublicKey(input: string): Wallet;

    /**
     * @description import a wallet (Version 1 of the Ethereum wallet format)
     * @param input
     * @param password
     */
    static fromV1(input: IV1Wallet | string, password: string): Wallet;

    /**
     * @description import a wallet (Version 3 of the Ethereum wallet format). Set nonStrict true to accept files with mixed-caps.
     * @param input
     * @param password
     * @param nonStrict
     */
    static fromV3(input: IV3Wallet | string, password: string, nonStrict: boolean): Wallet;

    /**
     * @description import an Ethereum Pre Sale wallet
     * @param input
     * @param password
     */
    static fromEthSale(input: IPresaleWallet | string, password: string): Wallet;
  }
}
